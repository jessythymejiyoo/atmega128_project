#define F_CPU 16000000UL
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

// =======================
// 설정
// =======================
#define BUZZER_PIN PB4       // 부저 핀
#define THRESHOLD_PM25 10    // PM2.5 기준 역치
#define SWITCH_PIN PE4       // 스위치
#define LED1 PA0
#define LED2 PA1
#define LED3 PA2

// PM 모드 정의
#define MODE_PM1_0 0
#define MODE_PM2_5 1
#define MODE_PM10  2

// 전역 변수
volatile uint8_t pm_mode = MODE_PM2_5; // 초기 모드: PM2.5

// =======================
// FND 테이블
// =======================
unsigned char number[10] = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
unsigned char fnd_select[4] = {0x08,0x04,0x02,0x01};
volatile unsigned char fnd_data[4] = {0,0,0,0};
volatile uint8_t fnd_index = 0;

// =======================
// UART1 (PMS7003)
// =======================
void UART1_init(void)
{
	UBRR1H = 0;
	UBRR1L = 103; // 9600bps
	UCSR1B = (1<<RXEN1);
	UCSR1C = (1<<UCSZ11) | (1<<UCSZ10);
}

uint8_t UART1_receive(void)
{
	while(!(UCSR1A & (1<<RXC1)));
	return UDR1;
}

uint8_t pms_frame_buf[32]; // PMS7003 데이터 프레임 저장 버퍼

// =======================
// PMS7003 데이터 읽기
// =======================
int getPMValue(void)
{
	uint8_t b;
	b = UART1_receive();
	if (b != 0x42) return -1;
	b = UART1_receive();
	if (b != 0x4D) return -1;

	pms_frame_buf[0] = 0x42;
	pms_frame_buf[1] = 0x4D;

	for (int i = 2; i < 32; i++)
	pms_frame_buf[i] = UART1_receive();

	switch(pm_mode) {
		case MODE_PM1_0:
		return ((uint16_t)pms_frame_buf[8] << 8) | pms_frame_buf[9];
		case MODE_PM2_5:
		return ((uint16_t)pms_frame_buf[10] << 8) | pms_frame_buf[11];
		case MODE_PM10:
		return ((uint16_t)pms_frame_buf[12] << 8) | pms_frame_buf[13];
		default:
		return -1;
	}
}

// =======================
// 부저 출력
// =======================
void custom_delay_us(int us) {
	for(int i=0;i<us;i++) _delay_us(1);
}

void beep_warning(void)
{
	float hz = 2000.0;
	int ms = 300;
	int us = (int)(500000.0 / hz);
	int count = (int)(ms*1000.0 / (2*us));

	for(int i=0;i<count;i++){
		PORTB |= (1<<BUZZER_PIN);
		custom_delay_us(us);
		PORTB &= ~(1<<BUZZER_PIN);
		custom_delay_us(us);
	}
}

// =======================
// LED 업데이트
// =======================
void update_led_mode(void) {
	PORTA &= ~((1<<LED1)|(1<<LED2)|(1<<LED3));
	switch(pm_mode){
		case MODE_PM1_0: PORTA |= (1<<LED1); break;
		case MODE_PM2_5: PORTA |= (1<<LED1)|(1<<LED2); break;
		case MODE_PM10:  PORTA |= (1<<LED1)|(1<<LED2)|(1<<LED3); break;
	}
}

// =======================
// FND 스캔 인터럽트 (1ms)
// =======================
ISR(TIMER0_COMP_vect)
{
	uint8_t idx = fnd_index;
	PORTG = 0x00; // FND 끄기

	if (idx==0 && fnd_data[idx]==0 && fnd_data[1]==0 && fnd_data[2]==0)
	PORTC = 0x00;
	else
	PORTC = number[fnd_data[idx]];

	PORTG = fnd_select[idx];
	fnd_index = (fnd_index+1)%4;
}

// =======================
// 스위치 인터럽트 (INT4)
// =======================
ISR(INT4_vect)
{
	if (!(PINE & (1<<SWITCH_PIN))) { // 눌림 확인
		_delay_ms(20); // 최소 디바운싱
		pm_mode = (pm_mode+1)%3;
		update_led_mode();

		// 모드 변경 즉시 FND 값 업데이트
		int pm = getPMValue();
		if (pm >= 0){
			if (pm>999) pm=999;
			fnd_data[0] = 0;
			fnd_data[1] = (pm/100)%10;
			fnd_data[2] = (pm/10)%10;
			fnd_data[3] = pm%10;
		}

		// 버튼 떼기 대기
		while (!(PINE & (1<<SWITCH_PIN))) _delay_ms(1);
	}
}

// =======================
// 메인
// =======================
int main(void)
{
	// 포트 설정
	DDRC = 0xFF;  // FND 세그먼트
	DDRG = 0x0F;  // FND 선택
	DDRB |= (1<<BUZZER_PIN); // 부저
	DDRA |= (1<<LED1)|(1<<LED2)|(1<<LED3);
	update_led_mode();

	DDRE &= ~(1<<SWITCH_PIN); // 스위치 입력
	PORTE |= (1<<SWITCH_PIN); // 풀업

	// 외부 인터럽트
	EICRB &= ~(1<<ISC40);
	EICRB |= (1<<ISC41);
	EIMSK |= (1<<INT4);

	UART1_init();

	// Timer0 1ms
	TCCR0 = (1<<WGM01)|(1<<CS01)|(1<<CS00); // CTC, 64분주
	OCR0 = 249;
	TIMSK |= (1<<OCIE0);

	sei(); // 전체 인터럽트 활성화

	while(1){
		int pm = getPMValue();

		if (pm >= 0){
			if (pm>999) pm=999;
			fnd_data[0] = 0;
			fnd_data[1] = (pm/100)%10;
			fnd_data[2] = (pm/10)%10;
			fnd_data[3] = pm%10;

			// 부저는 PM2.5 모드에서만
			if (pm_mode==MODE_PM2_5 && pm >= THRESHOLD_PM25)
			beep_warning();
		}
		_delay_ms(500); // 센서 업데이트 주기
	}
}
